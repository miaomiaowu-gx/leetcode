## 606. 根据二叉树创建字符串🍓  

```
你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。 

空节点则用一对空括号 "()" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。 

示例 1: 
输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     
输出: "1(2(4))(3)"
解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。

示例 2: 
输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 
输出: "1(2()(4))(3)"
解释: 和第一个示例相似，除了[不能省略第一个对括号]来中断输入和输出之间的一对一映射关系。

Related Topics 树 字符串 
```

### 方法一、迭代-栈先入右节点再入左节点


用一个栈来存储树中的一些节点，用一个集合存储所有遍历过的节点。

1.把根节点入栈。对于当前栈顶的元素，如果它没有遍历过，那么就把它加入到集合中，并开始对以它为根的子树进行前序遍历。
2.先在答案末尾添加一个 `(`，表示一个节点的开始，然后判断该节点的子节点个数。会出现四种情况：
* 如果它没有子节点，什么都不做；
* 如果它有两个子节点，那么先将右孩子入栈，再将左孩子入栈，这样就保证了前序遍历的顺序；
* 如果它只有左孩子，那么将左孩子入栈；
* 如果它只有右孩子，那么在答案末尾添加一个 `()` 表示空的左孩子，再将右孩子入栈。
3.用集合来存储遍历过的节点，如果当前栈顶的元素遍历过，那么就知道需要在答案末尾添加 `)`，并将这个节点出栈。

```java
public class Solution {
    public String tree2str(TreeNode t) {
        if (t == null)
            return "";
        Stack < TreeNode > stack = new Stack < > ();
        stack.push(t);
        Set < TreeNode > visited = new HashSet < > ();
        StringBuilder s = new StringBuilder();
        while (!stack.isEmpty()) {
            t = stack.peek();
            if (visited.contains(t)) {
                stack.pop();
                s.append(")");
            } else {
                visited.add(t);
                s.append("(" + t.val);
                if (t.left == null && t.right != null)
                    s.append("()");
                if (t.right != null)
                    stack.push(t.right);
                if (t.left != null)
                    stack.push(t.left);
            }
        }
        return s.substring(1, s.length() - 1);
    }
}
```

**复杂度分析**

* 时间复杂度：O(N)，其中 N 是二叉树中的节点数目。

* 空间复杂度：O(N)，在最坏情况下，栈中会存放 N 个节点。


另一种遍历树的方法（一直遍历左子树，左子树为空，遍历右子树）暂时没有写出来。

### 方法二、递归

使用递归的方法得到二叉树的前序遍历。在递归时，根据题目描述，需要加上额外的括号，会有以下 4 种情况：
* 如果当前节点有两个孩子，那在递归时，需要在两个孩子的结果外都加上一层括号；
* 如果当前节点没有孩子，那不需要在节点后面加上任何括号；
* 如果当前节点只有左孩子，那在递归时，只需要在左孩子的结果外加上一层括号，而不需要给右孩子加上任何括号；
* 如果当前节点只有右孩子，那在递归时，需要先加上一层空的括号 `()` 表示左孩子为空，再对右孩子进行递归，并在结果外加上一层括号。

```java
class Solution {
    public String tree2str(TreeNode t) {
        if(t==null)
            return "";
        if(t.left==null && t.right==null)
            return t.val+"";
        if(t.right==null)
            return t.val+"("+tree2str(t.left)+")";
        return t.val+"("+tree2str(t.left)+")("+tree2str(t.right)+")";
    }
}
```

**复杂度分析**

* 时间复杂度：O(N)，其中 N 是二叉树中的节点数目。

* 空间复杂度：O(N)，在最坏情况下，会递归 N 层，需要 O(N) 的栈空间。




















